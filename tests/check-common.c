/*
 * This file is part of cve-check-tool
 *
 * Copyright Â© 2015-2016 Intel Corporation
 *
 * cve-check-tool is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * As an additional permission, the right to link to OpenSSL is granted.
 */

#define _GNU_SOURCE
#include <check.h>
#include <nica.h>
#include <stdlib.h>

#include "config.h"
#include "fetch.h"
#include "files.h"
#include "util.h"

START_TEST(cve_common_parser)
{
        const char *path = TOP_DIR "/tests/data/common/nvdcve-2.0-2002.meta";
        const char *path2 = TOP_DIR "/tests/data/common/nvdcve-2.0-2002.meta.xtests";
        autofree(NcHashmap) *map = NULL;
        const char *val = NULL;
        const char *good_keys[] = { "lastModifiedDate", "size", "zipSize", "gzSize", "sha256" };
        const char *bad_keys[] = { "rudolph", "the", "red", "nosed", "reindeer" };
        const char *hash = "abc1c569de5e3e612fb6e0045cfa6859aa5cfc6282ed0f6db166120effae4843";

        map = cve_parse_delim_file(path, ':');
        fail_if(!map, "Failed to parse known file\n");

        val = nc_hashmap_get(map, "sha256");
        fail_if(!streq(val, hash), "Failed to get correct value from mapping");

        for (int i = 0; i < ARRAY_SIZE(good_keys); i++) {
                fail_if(!nc_hashmap_contains(map, good_keys[i]),
                        "Config file doesn't contain expected key");
        }

        for (int i = 0; i < ARRAY_SIZE(bad_keys); i++) {
                fail_if(nc_hashmap_contains(map, bad_keys[i]),
                        "Config file contains unexpected key");
        }

        nc_hashmap_free(map);

        map = cve_parse_delim_file(TOP_DIR "/tests/bob/does/not/exist", ':');
        fail_if(map, "Non existent file should not parse");

        /* Comments, blanks */
        map = cve_parse_delim_file(path2, ':');
        fail_if(!map, "Failed to open known path2");
        fail_if(nc_hashmap_size(map) != 5, "Incorrect keys for path2");
        nc_hashmap_free(map);

        map = cve_parse_delim_file(path, '=');
        fail_if(!map, "Failed to open known file");
        fail_if(nc_hashmap_size(map) != 0,
                "= mapping not used in this file. Should have no values");

        return;
}
END_TEST

START_TEST(cve_common_gunzip_sha_test)
{
        const char *expected = "82ee15b9459f7088e2a39b32d9e879c2bb6d08b0d13bb21f696fc2b38827fee1";
        const char *path = TOP_DIR "/tests/data/common/Test.gz";
        const char *xpath = TOP_DIR "/tests/data/common/Test-X.gz";
        const char *out_path = TOP_BUILD_DIR "/tests/data/common/Test.gunzip";
        autofree(char) *hash = NULL;

        /* Try some fakes first */
        fail_if(cve_gunzip_file(xpath, out_path, 00755),
                "Somehow gunzip'd file that doesn't exist");

        /** Just for sanity */
        nc_mkdir_p(TOP_BUILD_DIR "/tests/data/common/", 00755);

        /* Extract to a directory that doesn't exist */
        fail_if(cve_gunzip_file(path, TOP_BUILD_DIR "/tests/data/common2-0/.gz", 00755),
                "Somehow extracted to non existent tree");

        fail_if(!cve_gunzip_file(path, out_path, 00644), "Failed to gunzip file");
        fail_if(!nc_file_exists(out_path), "Gunzip'd file does not exist");

        hash = cve_get_sha256sum(xpath);
        fail_if(hash, "Somehow got hash for not existing file");

        hash = cve_get_sha256sum(out_path);
        fail_if(!hash, "Failed to get hashsum");

        fail_if(!streq(expected, hash), "Expected hash does not match that of gunzip'd file");
}
END_TEST

START_TEST(cve_common_fetch_test)
{
        const char *base_uri = "file://" TOP_DIR "/tests/data/common/Test.gz";
        const char *out_path = TOP_BUILD_DIR "/tests/data/common/Test.fetch.gz";
        const char *wrong_uri = "file:///rofl/copters.!";

        fail_if(!cve_fetch_file(NULL, base_uri, out_path, true), "Failed to fetch a known file!");
        fail_if(cve_fetch_file(NULL, wrong_uri, out_path, true),
                "Managed to fetch an unknown file.");
}
END_TEST

/**
 * Basic inline functions
 */
START_TEST(cve_common_basic)
{
        int64_t now = cve_utc_time_now();
        fail_if(now < 0, "Failed to get UTC time now");
}
END_TEST

/**
 * XML dates
 */
START_TEST(cve_common_xml_date)
{
        const char *dates[] = {
                "2016-02-10T21:54:25-05:00",     /* - 5hr offset */
                "2016-04-23T03:04:36-04:00",     /* -4hr offset */
                "2010-08-21T01:36:33.997-04:00", /* - offset */
                "2010-08-21T01:36:33.997+04:00", /* + offset */
                "2016-04-23T03:04:36-04:30",     /* offset minutes */
        };

        const int64_t expected[] = { 1455159265, 1461395076, 1282368993, 1282340193, 1461396876 };

        for (size_t i = 0; i < ARRAY_SIZE(dates); i++) {
                int64_t d = parse_iso8601_date(dates[i]);
                fail_if(d != expected[i], "Incorrect conversion in XML date");
        }
}
END_TEST

static Suite *core_suite(void)
{
        Suite *s = NULL;
        TCase *tc = NULL;

        s = suite_create("cve_common");
        tc = tcase_create("cve_common_functions");
        tcase_add_test(tc, cve_common_parser);
        tcase_add_test(tc, cve_common_gunzip_sha_test);
        tcase_add_test(tc, cve_common_basic);
        tcase_add_test(tc, cve_common_xml_date);
        tcase_add_test(tc, cve_common_fetch_test);
        suite_add_tcase(s, tc);

        return s;
}

int main(void)
{
        Suite *s;
        SRunner *sr;
        int fail;

        s = core_suite();
        sr = srunner_create(s);
        srunner_run_all(sr, CK_VERBOSE);
        fail = srunner_ntests_failed(sr);
        srunner_free(sr);

        if (fail > 0) {
                return EXIT_FAILURE;
        }

        return EXIT_SUCCESS;
}

/*
 * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
 *
 * Local variables:
 * c-basic-offset: 8
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 *
 * vi: set shiftwidth=8 tabstop=8 expandtab:
 * :indentSize=8:tabSize=8:noTabs=true:
 */
