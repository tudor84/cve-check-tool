/*
 * This file is part of cve-check-tool
 *
 * Copyright Â© 2015-2016 Intel Corporation
 *
 * cve-check-tool is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * As an additional permission, the right to link to OpenSSL is granted.
 */

#include "nvd-helper.h"

bool nvd_init_statements(NvdDatasource *self)
{
        autofree(NcHashmap) *ini_file = NULL;
        NcHashmapIter iter = { 0 };
        const char *key = NULL;
        NcHashmap *value = NULL;

        const char *init_paths[] = {
                DATADIR "/sqlite3.ini", TOP_DIR "/src/datasource/nvd/sqlite3.ini",
        };

        for (size_t i = 0; i < ARRAY_SIZE(init_paths); i++) {
                if (!nc_file_exists(init_paths[i])) {
                        continue;
                }
                ini_file = nc_ini_file_parse(init_paths[i]);
                if (i != 0) {
                        fprintf(stderr, "WARNING: Loading NVD INI from: %s\n", init_paths[i]);
                }
                break;
        }
        if (!ini_file) {
                fprintf(stderr, "Failed to load prepared statements config\n");
                return false;
        }

        /* Outer loop: Iterate sections */
        nc_hashmap_iter_init(ini_file, &iter);
        while (nc_hashmap_iter_next(&iter, (void **)&key, (void **)&value)) {
                NcHashmapIter inner_iter = { 0 };
                const char *trans_key = NULL;
                const char *trans_val = NULL;

                nc_hashmap_iter_init(value, &inner_iter);

                /* Inner loop: Iterate keys */
                while (
                    nc_hashmap_iter_next(&inner_iter, (void **)&trans_key, (void **)&trans_val)) {
                        autofree(char) *transaction_key = NULL;
                        sqlite3_stmt *statement = NULL;
                        int rc = -1;

                        if (!asprintf(&transaction_key, "%s.%s", key, trans_key)) {
                                fputs("OOM\n", stderr);
                                return false;
                        }

                        rc = sqlite3_prepare_v2(self->database, trans_val, -1, &statement, NULL);
                        if (rc != SQLITE_OK) {
                                fprintf(stderr,
                                        "nvd_init_statements(): Invalid statement %s: %s\n",
                                        transaction_key,
                                        sqlite3_errmsg(self->database));
                                return false;
                        }

                        if (!nc_hashmap_put(self->statements, strdup(transaction_key), statement)) {
                                fputs("OOM\n", stderr);
                                return false;
                        }
                }
        }
        return true;
}

bool nvd_prepare_statement_va(sqlite3_stmt *stm, va_list va)
{
        int column = 1;
        NvdSqlValue *value = NULL;
        int rc;

        if (!stm) {
                return false;
        }

        while ((value = va_arg(va, NvdSqlValue *)) != NULL) {
                switch (value->type) {
                case NSQL_TYPE_INT:
                        rc = sqlite3_bind_int(stm, column, value->v_int);
                        break;
                case NSQL_TYPE_INT64:
                        rc = sqlite3_bind_int64(stm, column, value->v_int64);
                        break;
                case NSQL_TYPE_STRING:
                        rc = sqlite3_bind_text(stm, column, value->v_string, -1, SQLITE_STATIC);
                        break;
                default:
                        fprintf(stderr, "nvd_prepare_statement_va(): Unknown type! Aborting\n");
                        abort();
                }

                if (rc != SQLITE_OK) {
                        return false;
                }
                ++column;
        }
        return true;
}

/*
 * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
 *
 * Local variables:
 * c-basic-offset: 8
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 *
 * vi: set shiftwidth=8 tabstop=8 expandtab:
 * :indentSize=8:tabSize=8:noTabs=true:
 */
