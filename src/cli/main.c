/*
 * This file is part of cve-check-tool
 *
 * Copyright © 2015-2016 Intel Corporation
 *
 * cve-check-tool is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * As an additional permission, the right to link to OpenSSL is granted.
 */

#include <nica.h>
#include <stdio.h>
#include <stdlib.h>

#include "cli.h"
#include "config.h"
#include "cve-config.h"
#include "util.h"

static void print_usage(CveTool *self);
static int print_help(CveTool *self, int argc, char **argv);
static SubCommand *get_subcommand(const char *key);

/**
 * Print version and exit
 */
static int print_version(__cve_unused__ CveTool *self, __cve_unused__ int argc,
                         __cve_unused__ char **argv)
{
        printf("cve-check-tool " PACKAGE_VERSION
               " \n\n"
               "Copyright © 2015-2016 Intel Corporation\n"
               "cve-check-tool is free software; you can redistribute it and/or\n"
               "modify it under the terms of the GNU General Public License as\n"
               "published by the Free Software Foundation; either version 2 of\n"
               "the License, or (at your option) any later version.\n");
        return EXIT_SUCCESS;
}

/**
 * Supported subcommands
 */
static SubCommand commands[] = {
        { "info", cmd_info, "Show information on a CVE", "info: [CVE ID]" },
        { "update", cmd_update, "Update the data sources", NULL },
        { "version", print_version, "Show version and quit", NULL },
        { "help", print_help, "Display this help message", "help: [command]" },
};

/**
 * Print usage and move on
 */
static void print_usage(CveTool *self)
{
        printf("Usage:  %s SUBCOMMAND\n\n", self->program_name);

        printf("Commands:\n");
        for (size_t i = 0; i < ARRAY_SIZE(commands); i++) {
                SubCommand com = commands[i];
                printf("%15s - %s\n", com.name, com.blurb);
        }
}

static int print_help(CveTool *self, int argc, __cve_unused__ char **argv)
{
        if (argc == 0) {
                print_usage(self);
                return EXIT_SUCCESS;
        }
        SubCommand *cmd = get_subcommand(argv[0]);
        if (!cmd) {
                fprintf(stderr, "Unknown command: %s\n", argv[0]);
                return EXIT_FAILURE;
        }
        if (!cmd->usage) {
                printf("%s %s\n\n%s\n", self->program_name, cmd->name, cmd->blurb);
        } else {
                printf("%s\n\n%s\n", cmd->name, cmd->usage);
        }
        /* TODO: Add further help body */
        return EXIT_SUCCESS;
}

/**
 * Return a named subcomamnd */
static SubCommand *get_subcommand(const char *key)
{
        for (size_t i = 0; i < ARRAY_SIZE(commands); i++) {
                if (streq(commands[i].name, key)) {
                        return &(commands[i]);
                }
        }
        return NULL;
}

int main(int argc, char **argv)
{
        const char *command = NULL;
        SubCommand *cmd = NULL;
        CveTool self = {.data_root = NULL, .program_name = argv[0] };
        autofree(CveConfig) *config = NULL;
        const char *rootdir = NULL;

        atexit(nc_dump_file_descriptor_leaks);
        ++argv;
        --argc;

        if (argc == 0) {
                print_usage(&self);
                return EXIT_FAILURE;
        }

        /* Check for the command */
        command = argv[0];
        cmd = get_subcommand(command);
        if (!cmd) {
                fprintf(stderr, "Unknown command: %s\n\n", command);
                print_usage(&self);
                return EXIT_FAILURE;
        }

        rootdir = getenv("HOME");
        if (!rootdir) {
                fprintf(stderr, "Environment failure: No home directory\n");
                return EXIT_FAILURE;
        }
        config = cve_config_new();
        if (!config) {
                fputs("Out of memory\n", stderr);
                return EXIT_FAILURE;
        }
        if (!cve_config_set(config, CONFIG_KEY_ROOT_DIRECTORY, rootdir)) {
                fputs("Out of memory\n", stderr);
                return EXIT_FAILURE;
        }
        self.config = config;

        /* While in development, check for implementation.. */
        if (!cmd->callback) {
                fprintf(stderr, "%s: not yet implemented\n", command);
                return EXIT_FAILURE;
        }

        --argc;
        ++argv;
        return cmd->callback(&self, argc, argv);
}

/*
 * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
 *
 * Local variables:
 * c-basic-offset: 8
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 *
 * vi: set shiftwidth=8 tabstop=8 expandtab:
 * :indentSize=8:tabSize=8:noTabs=true:
 */
